import { sendIframeMessage, waitForIframeLoading } from '../../utils/iframe'

interface CreateImagesFromMetaAIParams {
  prompt: string
  aspectRatio?: '1:1' | '9:16' | '16:9'
}

export async function createImagesFromMetaAI({
  prompt,
  aspectRatio,
}: CreateImagesFromMetaAIParams): Promise<string[]> {
  prompt = 'Create an image : ' + prompt
  const selectors: {
    promptInput: string
    aspectRatioSelector: string
    aspectRatios: {
      '1:1': string
      '9:16': string
      '16:9': string
    }
    submitButton: string
    imageContainer?: string
    thumbnailImageElement: string
    largeImageElement: string
    closeLargeImageButton: string
  } = {
    promptInput: 'div[role="textbox"]', // Actual selector for Meta AI's prompt input
    aspectRatioSelector: 'div[aria-label="Selector options"] div[role="button"]',
    aspectRatios: {
      '1:1': 'div[style*="transform: translate"] div[role="menu"] div[role="menuitem"]:nth-child(1)',
      '9:16': 'div[style*="transform: translate"] div[role="menu"] div[role="menuitem"]:nth-child(2)',
      '16:9': 'div[style*="transform: translate"] div[role="menu"] div[role="menuitem"]:nth-child(3)',
    },
    submitButton: 'div[aria-label="Send message"]', // Actual selector for Meta AI's send/generate button
    // imageContainer: 'div[aria-label^="Image generation results"]', // Optional: A container holding all thumbnails
    thumbnailImageElement: 'img[alt*="Image generated by meta.ai"]', // Actual selector for individual thumbnail images
    largeImageElement: 'div[role="dialog"] img[src*="fbcdn"]', // Actual selector for the large image when a thumbnail is clicked
    closeLargeImageButton: 'div[aria-label="Close"]', // Optional: Selector for a close button on the large image view
  }
  // Use imageContainer if provided, otherwise fallback to imageElement for waiting.
  const waitSelectorForThumbnails = selectors.imageContainer || selectors.thumbnailImageElement

  const iframe = document.createElement('iframe')
  iframe.src = 'https://www.meta.ai/'
  iframe.style.width = '1024px'
  iframe.style.height = '768px'
  iframe.style.zIndex = '-1'
  iframe.style.position = 'fixed'
  iframe.style.top = '0px'
  iframe.style.opacity = '0'
  iframe.style.border = '1px solid #ccc'
  document.body.appendChild(iframe)

  try {
    console.log('Waiting for iframe to load...')
    await waitForIframeLoading(iframe)
    console.log('Iframe loaded.')

    // 1. Wait for the prompt input field to be available
    console.log('Waiting for prompt input field:', selectors.promptInput)
    await sendIframeMessage(iframe, {
      message: 'waitForElement',
      selector: selectors.promptInput,
      timeout: 20000, // Wait up to 20s for the page to fully load.
      pollInterval: 1000, // Poll every second
    })
    console.log('Prompt input field found.')

    // 2. Input the prompt
    console.log('Typing prompt:', prompt)
    await sendIframeMessage(iframe, {
      message: 'textInput',
      selector: selectors.promptInput,
      text: prompt,
    })
    console.log('Prompt typed.')

    // 3. Wait for the submit button to be available/clickable
    console.log('Waiting for submit button:', selectors.submitButton)
    await sendIframeMessage(iframe, {
      message: 'waitForElement',
      selector: selectors.submitButton,
      timeout: 10000,
    })
    console.log('Submit button found.')

    if (aspectRatio) {
      console.log('Waiting for aspect ratio selector:', selectors.aspectRatioSelector)
      await sendIframeMessage(iframe, {
        message: 'waitForElement',
        selector: selectors.aspectRatioSelector,
        timeout: 10000,
      })
      console.log('Aspect ratio selector found.')
      console.log('Clicking aspect ratio selector.')
      await sendIframeMessage(iframe, {
        message: 'click',
        selector: selectors.aspectRatioSelector,
      })
      console.log('Aspect ratio selector clicked.')
      const aspectRatioSelector = selectors.aspectRatios[aspectRatio]
      if (aspectRatioSelector) {
        console.log('Waiting for aspect ratio:', aspectRatio)
        await sendIframeMessage(iframe, {
          message: 'waitForElement',
          selector: aspectRatioSelector,
          timeout: 10000,
        })
        console.log('Aspect ratio found.')
        console.log('Clicking aspect ratio.')
        await sendIframeMessage(iframe, {
          message: 'click',
          selector: aspectRatioSelector,
        })
        console.log('Aspect ratio clicked.')
      }
    }

    // 4. Click the submit button
    console.log('Clicking submit button.')
    await sendIframeMessage(iframe, {
      message: 'click',
      selector: selectors.submitButton,
    })
    console.log('Submit button clicked.')

    // 5. Wait for images to appear.
    console.log('Waiting for thumbnail image results using selector:', waitSelectorForThumbnails)
    await sendIframeMessage(iframe, {
      message: 'waitForElement',
      selector: waitSelectorForThumbnails,
      timeout: 180000, // Image generation can take time (e.g., up to 3 minutes),
    })
    console.log('Thumbnail image results detected.')

    // Optional: Add a small delay to ensure all images are fully rendered if they load sequentially
    await new Promise((resolve) => setTimeout(resolve, 2000))

    // 6. Get the DOM to identify all thumbnails
    console.log('Fetching DOM to identify thumbnails.')
    const initialDomData = await sendIframeMessage(iframe, {
      message: 'getDOM',
      timeout: 10000,
    })

    if (!initialDomData || !initialDomData.html) {
      throw new Error('Failed to retrieve initial DOM from iframe to find thumbnails.')
    }

    const parser = new DOMParser()
    const iframeDoc = parser.parseFromString(initialDomData.html, 'text/html')
    const thumbnailElements = iframeDoc.querySelectorAll(selectors.thumbnailImageElement)

    console.log(`Found ${thumbnailElements.length} thumbnail image elements.`)
    const largeImageUrls: string[] = []

    for (let i = 0; i < thumbnailElements.length; i++) {
      console.log(`Processing thumbnail ${i + 1} of ${thumbnailElements.length}`)

      // Click the i-th thumbnail.
      // This assumes content.js can handle an 'index' property for the 'click' message.
      // If not, you'd need a way to generate a unique selector for each thumbnail.
      await sendIframeMessage(iframe, {
        message: 'click',
        selector: `div:nth-child(${i + 1}) > div > div > div > div > div > div > div > ${
          selectors.thumbnailImageElement
        }`,
        timeout: 5000,
      })
      console.log(`Clicked thumbnail ${i + 1}.`)

      // Wait for the large image to appear
      console.log('Waiting for large image:', selectors.largeImageElement)
      await sendIframeMessage(iframe, {
        message: 'waitForElement',
        selector: selectors.largeImageElement,
        timeout: 10000, // Adjust as needed
      })
      console.log('Large image detected.')
      await new Promise((resolve) => setTimeout(resolve, 1000)) // Small delay for rendering

      // Attempt to get the large image URL directly via its src attribute
      let largeImageUrl
      try {
        const imageData = await sendIframeMessage(iframe, {
          message: 'getElementAttribute', // Assumes content.js supports this
          selector: selectors.largeImageElement,
          attribute: 'src',
          timeout: 5000,
        })
        largeImageUrl = imageData ? imageData.value : null
      } catch (e: any) {
        console.warn('Failed to get large image src via getElementAttribute:', e.message)
      }

      // Fallback: if direct attribute fetch failed or returned no URL, get full DOM and parse
      if (!largeImageUrl) {
        console.log('Falling back to getDOM to extract large image URL.')
        const currentDomData = await sendIframeMessage(iframe, {
          message: 'getDOM',
          timeout: 10000,
        })
        if (currentDomData && currentDomData.html) {
          const currentIframeDoc = parser.parseFromString(currentDomData.html, 'text/html')
          const largeImgEl = currentIframeDoc.querySelector(
            selectors.largeImageElement
          ) as HTMLImageElement
          if (largeImgEl) {
            let url = largeImgEl.src || largeImgEl.getAttribute('data-src')
            if (!url && largeImgEl.srcset) {
              const sources = largeImgEl.srcset.split(',').map((s) => s.trim().split(' ')[0])
              url = sources[0]
            }
            if (!url && largeImgEl.style && largeImgEl.style.backgroundImage) {
              const bgImage = largeImgEl.style.backgroundImage
              const urlMatch = bgImage.match(/url\("?(.+?)"?\)/)
              if (urlMatch && urlMatch[1]) {
                url = urlMatch[1]
              }
            }
            largeImageUrl = url // Assign to largeImageUrl to be processed below
          } else {
            console.warn('Large image element not found in fallback DOM parse.')
          }
        } else {
          console.warn('Failed to retrieve DOM for fallback large image URL extraction.')
        }
      }

      if (largeImageUrl) {
        try {
          // Use initialDomData.href as base, or currentDomData.href if available from fallback
          const baseHref = (initialDomData && initialDomData.href) || 'https://www.meta.ai'
          largeImageUrl = new URL(largeImageUrl, baseHref).href
        } catch (e: any) {
          console.warn(
            `Could not make large image URL absolute: "${largeImageUrl}". Using as is. Error: ${e.message}`
          )
        }
        if (largeImageUrl.startsWith('blob:')) {
          console.warn('Found blob URL for large image:', largeImageUrl)
        }
        largeImageUrls.push(largeImageUrl)
        console.log(`Extracted large image URL: ${largeImageUrl}`)
      } else {
        console.warn(`Could not extract URL for large image (thumbnail index ${i}).`)
      }

      // If there's a close button for the large image modal, click it
      if (selectors.closeLargeImageButton) {
        console.log(
          'Attempting to close large image view using selector:',
          selectors.closeLargeImageButton
        )
        try {
          await sendIframeMessage(iframe, {
            message: 'click',
            selector: selectors.closeLargeImageButton,
            timeout: 5000,
          })
          console.log('Large image view closed.')
          await new Promise((resolve) => setTimeout(resolve, 1000)) // Wait for UI to settle
        } catch (closeError: any) {
          console.warn(
            'Could not click close button for large image view (or button not found):',
            closeError.message
          )
          // Depending on the site, this might or might not be critical
        }
      }
    }

    console.log('Extracted all large image URLs:', largeImageUrls)
    return largeImageUrls
  } catch (error: any) {
    console.error('Error in generateImagesFromMetaAI:', error.message, error.stack)
    throw error // Re-throw the error
  } finally {
    // 7. Clean up: remove the iframe
    if (iframe && iframe.parentNode) {
      iframe.parentNode.removeChild(iframe)
      console.log('Iframe removed.')
    }
  }
}
